library(R.matlab) # Reads matlab files
library(stringr) # String manipulation
library(readr)
library(raster)
library(changepoint)
# NOTE: should have the folder "MatFiles" downloaded and extracted to the location below
# Should have the files "disposition.xls" and "randomization.xlsx" in locations below

## Grab all of the .mat Files from directory H:\\V2VMAT\\MatFiles
files <- list.files("H:\\V2VMAT\\MatFiles")
disp <- readxl::read_excel("H:\\V2VMAT\\disposition.xls")
disp$DaqName2 <- str_replace(disp$DaqName, ".daq", ".mat")
rand <- readxl::read_excel("H:\\V2VMAT\\randomization.xlsx")
rand$`Participant#`<- as.numeric(rand$`Participant#`)
df <- data.frame(Part_ID = numeric(), Alert_C = character(), Alert_L = character(), Safety = numeric())

for (i in 1:length(files)){
  pos <- which(disp$DaqName2 == files[i])
  ID <- parse_number(disp[pos, ]$DaqPath)
  ## select all MN files
  if (str_sub(disp[pos, ]$DaqPath, -2, -1) == "MN" & ID <= 180){
    alert_char <- rand[which(rand$`Participant#` == ID),]$Characteristic
    alert_level <- rand[which(rand$`Participant#` == ID),]$AlertLevel
    
    
    
    m1 <- readMat(paste0("H:\\V2VMAT\\MatFiles\\",files[i]))
    
    part1speed <- m1$elemDataI[[which(rownames(m1$elemDataI) == 'VDS.Veh.Speed')]]
    part1time <- m1$elemDataI[[which(rownames(m1$elemDataI) == 'Time')]]
    part1heading <- m1$elemDataI[[which(rownames(m1$elemDataI) == 'VDS.Veh.Heading')]]
    part1logstream <- m1$elemDataI[[which(rownames(m1$elemDataI) == 'SCC.LogStreams')]][,1]
    
    df1 <- data.frame("time" =  part1time,"speed" = part1speed,"heading" = part1heading, "logstream" = part1logstream)
    ## only look at logstream 2
    incdf1 <- df1[which(df1$logstream != 0 & df1$logstream != 3),names(df1) %in% c("time","speed","heading","logstream")]
    
    ##speed from mph into m/s
    incdf1$speed <- 0.44704*incdf1$speed
    
    ##heading angle from degree to radian and set facing direction to be 0
    incdf1$heading <- incdf1$heading*pi/180
    incdf1$heading <- incdf1$heading - pi
    
    ##finding acceleration
    for (j in 1:length(incdf1$time)) {
      if (j ==1) {
        incdf1$acceleration[j] = 0
        incdf1$wheel[j] = 0
      }
      else{
        incdf1$acceleration[j] <- (incdf1$speed[j] -  incdf1$speed[j-1])  * 60
        incdf1$wheel[j] <- (incdf1$heading[j] - incdf1$heading[j-1]) * 60
      }
    }
    ##set initial acceleration
    incdf1$acceleration[1] <- incdf1$acceleration[2]
    
    ## change point detection for acceleration and wheel angle
    try1 <- cpt.meanvar(incdf1$acceleration)
    try2 <- cpt.meanvar(incdf1$wheel)
    
    ##find first reaction
    if (attr(try1, "cpts")[1] < attr(try2, "cpts")[1]){
      try <- try1
    } else{
      try <- try2
    }
    
   
    
    minwheel <- max(abs(incdf1$wheel[1:60]))*1.2
    
    
    
    ##change time so that t0 is first reaction 
    time_change <- incdf1$time[match(TRUE, incdf1$logstream == 2)]
    ##speed of car Q == speed of car P at logstream 2
    speed_Q <- incdf1$speed[match(TRUE, incdf1$logstream == 2)]
    incdf1$time <- incdf1$time - time_change
    ##predicted colision (2.9s)
    time_end <- 2.90 - incdf1$time[attr(try, "cpts")[1]]
    ##new incdf1
    incdf1 <- incdf1[attr(try, "cpts")[1]:nrow(incdf1),]
    incdf1 <- na.omit(incdf1)
    incdf1$time <- incdf1$time - incdf1$time[1]
    
    
    
    ##breaking (acceleration decreasing)
    if (incdf1$speed[6] < incdf1$speed[1]){
      acc <- (incdf1$speed[incdf1$acceleration==min(incdf1$acceleration)] - incdf1$speed[incdf1$time == 0])/ incdf1$time[incdf1$acceleration == min(incdf1$acceleration)]
      time_stop <- -incdf1$speed[1]/acc
      } else {
      acc <- (incdf1$speed[incdf1$acceleration==max(incdf1$acceleration)] - incdf1$speed[incdf1$time == 0])/ incdf1$time[incdf1$acceleration == max(incdf1$acceleration)]
      time_stop <- 100
    }
    
    ##calculating Zp when Zq is 0
    ##not steering
    if (minwheel >= max(abs(incdf1$wheel)))
    {
      
    if (time_end <= time_stop){
      Zp <- (time_end*incdf1$speed[1]- time_end*incdf1$speed[1] - acc/2*time_end^2)/incdf1$speed[1]
    } else{
      Zp <- (time_end*incdf1$speed[1]- time_stop*incdf1$speed[1] - acc/2*time_stop^2)/incdf1$speed[1]
    }
    }
    
    ##steering
    else{
      wheel <- (incdf1$heading[which.max(abs(incdf1$wheel))]-0)/incdf1$time[which.max(abs(incdf1$wheel))]
      ## t is the variable time 
  
      heading <- t * wheel
      Posqy <- 0
      Posqx <- (time_end - t) *speed_Q
      Pospy <- -time_end*incdf1$speed[1]+incdf1$speed[1]*t+acc*(wheel*t*sin(heading)+cos(heading))/wheel^2
      Pospx <- acc*(sin(heading)-wheel*t*cos(heading))/wheel^2
      
    }
    
    de <- data.frame(Part_ID = ID, Alert_C = alert_char, Alert_L = alert_level, Safety = Zp)
    df <- rbind(df, de)
    
    
  }
}

qx_px <- function(t, time_end, speed_Q, wheel, acc){
  (time_end - t)*speed_Q-acc*(sin(wheel*t)-wheel*t*cos(wheel*t))/wheel^2
}
py <- function(t, time_end, speed_P, wheel, acc){
  
  -time_end*speed_P+speed_P*t+acc*(wheel*t*sin(wheel*t)+cos(wheel*t))/wheel^2
}

result <- uniroot(qx_px, time_end = time_end, speed_Q = speed_Q, wheel = wheel, acc = acc, interval = c(0,100))
Zp <- py(result$root,time_end,incdf1$speed[1],wheel,acc)/incdf1$speed[1]

py(result$root,time_end,incdf1$speed[1],wheel,acc)
