df <- data.frame(Part_ID = numeric(), Alert_C = character(), Alert_L = character(), Safety = numeric())
 data <- read.csv("H:\\V2VMAT\\haptic_data.csv")
 
   
   for (i in 1:unique(data$Part_ID)){
      ## select all MN files
        
           m1 <- data[data$Part_ID==1,]
           
             
           
             ## change point detection for acceleration and wheel angle
             try1 <- cpt.meanvar(m1$acceleration)
           try2 <- cpt.meanvar(m1$wheel)
             
               ##find first reaction
               if (attr(try1, "cpts")[1] < attr(try2, "cpts")[1]){
                   try <- try1
                 } else{
                     try <- try2
                   }
            
              
             minwheel <- max(abs(m1$wheel[1:60]))*1.2
              
              
                 ##change time so that t0 is first reaction 
                 time_change <- m1$time[match(TRUE, m1$logstream == 2)]
                 ##speed of car Q == speed of car P at logstream 2
                   speed_Q <- m1$speed[match(TRUE, m1$logstream == 2)]
                   m1$time <- m1$time - time_change
                 ##predicted colision (2.9s)
                      time_end <- 2.90 - m1$time[attr(try, "cpts")[1]]
                     ##new incdf1
                       m1 <- m1[attr(try, "cpts")[1]:nrow(m1),]
                       m1 <- na.omit(m1)
                       m1$time <- m1$time - m1$time[1]
                       
                         
                         
                         ##breaking (acceleration decreasing)
                         if (m1$speed[6] < m1$speed[1]){
                             acc <- (m1$speed[m1$acceleration==min(m1$acceleration)] - m1$speed[m1$time == 0])/ m1$time[m1$acceleration == min(m1$acceleration)]
                             time_stop <- -m1$speed[1]/acc
                            } else {
                               acc <- (m1$speed[m1$acceleration==max(m1$acceleration)] - m1$speed[m1$time == 0])/ m1$time[m1$acceleration == max(m1$acceleration)]
                              time_stop <- 100
                            }
                       
                         ##calculating Zp when Zq is 0
                         ##not steering
                         if (minwheel >= max(abs(m1$wheel)))
                           {
                             
                               if (time_end <= time_stop){
                                     Zp <- (time_end*m1$speed[1]- time_end*m1$speed[1] - acc/2*time_end^2)/m1$speed[1]
                                   } else{
                                       Zp <- (time_end*m1$speed[1]- time_stop*m1$speed[1] - acc/2*time_stop^2)/m1$speed[1]
                                   }
                             }
                       else{
                         ##steering
                             wheel <- (m1$heading[which.max(abs(m1$wheel))]-0)/m1$time[which.max(abs(m1$wheel))]
                             ## t is the variable time 
                               
                               heading <- t * wheel
                               Posqy <- 0
                              Posqx <- function(t, time_end, speed_Q){
                                   (time_end - t) *speed_Q
                                   }
                             velpy <- (speed_P + acc*t)*cos(wheel*t)
                             Pospy <- function(t, time_end, speed_P, wheel, acc){
                                   -time_end*speed_P+(speed_P*sin(wheel*t)/wheel+acc*(wheel*t*sin(wheel*t)+cos(wheel*t))/wheel^2)-acc/wheel^2
                                 
                                   }
                               
                                
                                  
                                 velpx <- -(m1$speed[1] + acc*t)*sin(wheel*t)
                                 Pospx <- function(t, speed_P, wheel, acc){
                                     -speed_P/wheel +(speed_P*cos(wheel*t)/wheel+acc*(-sin(wheel*t)+wheel*t*cos(wheel*t))/wheel^2)
                                     }
                                 
                                   qx_px <- function(t, time_end, speed_Q, speed_P,wheel, acc){
                                       Posqx(t, time_end, speed_Q)-Pospx(t, speed_P, wheel, acc)
                                     }
                                   
                                     result <- uniroot(qx_px, time_end = time_end, speed_Q = speed_Q, speed_P = m1$speed[1], wheel = wheel, acc = acc, interval = c(0,10))
                                     Zp <- Pospy(result$root,time_end,m1$speed[1],wheel,acc)/m1$speed[1]
                                   
                                     de <- data.frame(Part_ID = m1$Part_ID, Safety = Zp)
                                     df <- rbind(df, de)
                                     
                                       
                                     }
   }
 
 length <- 15.74*0.3048
 width <- 6.07*0.3048
 diag <- sqrt(length^2 + width^2)/2
 angle <- atan(length/width)
 
 
 ##position of points p1-4, q1-4
 Posp1x <- function(t, speed_P, wheel, acc){
   Pospx(t,m1$speed[1],wheel,acc)-diag*sin(wheel*t+angle)
 }
 Posp1y <- function(t, time_end, speed_P, wheel, acc){
   Pospy(t,time_end,m1$speed[1],wheel,acc)+diag*cos(wheel*t+angle)
 }
 Posp2x <- function(t, speed_P, wheel, acc){
   Pospx(t,m1$speed[1],wheel,acc)+diag*sin(-wheel*t+angle)
 }
 Posp2y <- function(t, time_end, speed_P, wheel, acc){
   Pospy(t,time_end,m1$speed[1],wheel,acc)+diag*cos(-wheel*t+angle)
 }
 Posp3x <- function(t, speed_P, wheel, acc){
   Pospx(t,m1$speed[1],wheel,acc)-diag*sin(-wheel*t+angle)
 }
 Posp3y <- function(t, time_end, speed_P, wheel, acc){
   Pospy(t,time_end,m1$speed[1],wheel,acc)-diag*cos(-wheel*t+angle)
 }
 Posp4x <- function(t, speed_P, wheel, acc){
   Pospx(t,m1$speed[1],wheel,acc)+diag*sin(wheel*t+angle)
 }
 Posp4y <- function(t, time_end, speed_P, wheel, acc){
   Pospy(t,time_end,m1$speed[1],wheel,acc)-diag*cos(wheel*t+angle)
 }
 
 Posq1x <- function(t, time_end, speed_Q){
   Posqx(t,time_end,speed_Q)-length/2
 }
 Posq1y <- -width/2
 Posq2x <- function(t, time_end, speed_Q){
   Posqx(t,time_end,speed_Q)-length/2
 }
 Posq2y <- width/2
 Posq3x <- function(t, time_end, speed_Q){
   Posqx(t,time_end,speed_Q)+length/2
 }
 Posq3y <- width/2
 Posq4x <- function(t, time_end, speed_Q){
   Posqx(t,time_end,speed_Q)+length/2
 }
 Posq4y <- -width/2
 
 
 P1slope <- function(t, time_end, speed_P, wheel, acc) {
 (Posp1y(t, time_end, speed_P, wheel, acc)-Posp1y(t, time_end, speed_P, wheel, acc))/(Posp2x(t, speed_P, wheel, acc)-Posp2x(t, speed_P, wheel, acc))
 }
 
 lineseg <- function(x, t, time_end, speed_P, wheel, acc){
 Posp1y(t, time_end, speed_P, wheel, acc)+(x-Posp1x(t, speed_P, wheel, acc))*P1slope(t, time_end, speed_P, wheel, acc)
 }
 
 lineperp <- function(x, t, time_end, speed_P, wheel, acc){
 Posq1y+(x-Posq1x(t, time_end, speed_Q))/-P1slope(t, time_end, speed_P, wheel, acc)
 }
 
 seg_perp <- function(x, t, time_end, speed_P, wheel, acc){
 lineseg(x, t, time_end, speed_P, wheel, acc) -lineperp(x, t, time_end, speed_P, wheel, acc)
 ]
 
distfunc <- function(t, time_end, speed_Q, speed_P, wheel, acc){
 inter <- uniroot(seg-perp, t=t, time_end=time_end, speed_P=speed_P, wheel=wheel, acc=acc)
 sqrt((inter$root - Posq1x)^2 + (lineseg(inter$root, t, time_end, speed_P, wheel, acc)-Posq1y)^2
 }
 
 Zp <- (Posq1y - lineseg(inter$root, t, time_end, speed_P, wheel, acc))/speed_P
 Zq <- (Posq1x - inter$root)/speed_Q
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

